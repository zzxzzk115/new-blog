<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Depth Pre-Pass and Early-Z | Kexuan Zhang's Blog</title><meta name=keywords content="Optimization,Render-Path,Depth Pre-Pass,Early-Z"><meta name=description content="We may have heard of these keywords: Depth Pre-Pass and Early-Z. But what situations do we actually need them for?

Overdraw
When rendering a complex 3D scene, multiple fragments may map to the same pixel on the screen ‚Äî for example, when one object is in front of another. The GPU will still execute the fragment shader for each layer of geometry, even though only the nearest fragment is visible in the final image.
This redundant work is called overdraw."><meta name=author content="Kexuan Zhang"><link rel=canonical href=https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/new-blog/assets/css/stylesheet.751a9480deb1fb8cecb5e0002a911746823db643ad4b730657aac9b10615ed03.css integrity="sha256-dRqUgN6x+4zsteAAKpEXRoI9tkOtS3MGV6rJsQYV7QM=" rel="preload stylesheet" as=style><link rel=icon href=https://zzxzzk115.github.io/new-blog/images/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zzxzzk115.github.io/new-blog/images/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zzxzzk115.github.io/new-blog/images/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://zzxzzk115.github.io/new-blog/images/favicon/apple-touch-icon.png><link rel=mask-icon href=https://zzxzzk115.github.io/new-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><script>MathJax={tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><div class=progress-bar></div><script>document.addEventListener("DOMContentLoaded",()=>{const t=document.querySelector(".progress-bar"),e=()=>{const e=window.innerHeight,n=document.documentElement.scrollHeight-e,s=window.scrollY,o=s/n*100;t.style.width=`${o}%`};window.addEventListener("scroll",e),e()})</script><meta property="og:url" content="https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/"><meta property="og:site_name" content="Kexuan Zhang's Blog"><meta property="og:title" content="Depth Pre-Pass and Early-Z"><meta property="og:description" content="We may have heard of these keywords: Depth Pre-Pass and Early-Z. But what situations do we actually need them for?
Overdraw When rendering a complex 3D scene, multiple fragments may map to the same pixel on the screen ‚Äî for example, when one object is in front of another. The GPU will still execute the fragment shader for each layer of geometry, even though only the nearest fragment is visible in the final image.
This redundant work is called overdraw."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-08T16:14:06+00:00"><meta property="article:modified_time" content="2025-11-08T16:14:06+00:00"><meta property="article:tag" content="Optimization"><meta property="article:tag" content="Render-Path"><meta property="article:tag" content="Depth Pre-Pass"><meta property="article:tag" content="Early-Z"><meta property="og:image" content="https://zzxzzk115.github.io/new-blog/cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zzxzzk115.github.io/new-blog/cover.png"><meta name=twitter:title content="Depth Pre-Pass and Early-Z"><meta name=twitter:description content="We may have heard of these keywords: Depth Pre-Pass and Early-Z. But what situations do we actually need them for?

Overdraw
When rendering a complex 3D scene, multiple fragments may map to the same pixel on the screen ‚Äî for example, when one object is in front of another. The GPU will still execute the fragment shader for each layer of geometry, even though only the nearest fragment is visible in the final image.
This redundant work is called overdraw."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zzxzzk115.github.io/new-blog/posts/"},{"@type":"ListItem","position":2,"name":"Depth Pre-Pass and Early-Z","item":"https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Depth Pre-Pass and Early-Z","name":"Depth Pre-Pass and Early-Z","description":"We may have heard of these keywords: Depth Pre-Pass and Early-Z. But what situations do we actually need them for?\nOverdraw When rendering a complex 3D scene, multiple fragments may map to the same pixel on the screen ‚Äî for example, when one object is in front of another. The GPU will still execute the fragment shader for each layer of geometry, even though only the nearest fragment is visible in the final image.\nThis redundant work is called overdraw.\n","keywords":["Optimization","Render-Path","Depth Pre-Pass","Early-Z"],"articleBody":"We may have heard of these keywords: Depth Pre-Pass and Early-Z. But what situations do we actually need them for?\nOverdraw When rendering a complex 3D scene, multiple fragments may map to the same pixel on the screen ‚Äî for example, when one object is in front of another. The GPU will still execute the fragment shader for each layer of geometry, even though only the nearest fragment is visible in the final image.\nThis redundant work is called overdraw.\nExcessive overdraw wastes both fill rate and shader computation resources, especially in scenes with heavy pixel shading (e.g., complex lighting or post-processing).\nMinimizing overdraw is one of the key goals of any rendering optimization strategy.\nThe Depth Buffer The depth buffer (Z-buffer) keeps track of the closest depth value written for each pixel so far.\nWhen a new fragment is processed, the GPU compares its depth with the stored value to decide whether it‚Äôs visible (passes the depth test) or hidden (fails the depth test).\nIf Depth Test Passes ‚Üí the fragment is drawn, and the depth buffer is updated. If Depth Test Fails ‚Üí the fragment is discarded before writing to the color buffer. However, the key question is when this depth comparison happens relative to fragment shading ‚Äî and this is where Early-Z and Depth Pre-Pass come into play.\nEarly-Z Modern GPUs implement Early-Z rejection, meaning the depth test can be performed before the fragment shader runs.\nIf a fragment fails the test (i.e., it‚Äôs behind something already drawn), the GPU can skip executing the pixel shader entirely.\nThis saves a huge amount of computation, especially with expensive fragment programs.\nBut Early-Z has some caveats:\nIt only works if the fragment shader doesn‚Äôt modify the depth value or use discard/alpha-test operations that could change visibility. Certain rendering states (e.g., blending, alpha testing) may force the GPU to disable Early-Z to maintain correct visual output. In short: Early-Z works automatically when your shaders are ‚Äúsimple‚Äù ‚Äî i.e., they don‚Äôt interfere with depth writes or discards.\nTo enable Early-Z explicitly in Vulkan, just add one line to your fragment shader:\n1 layout(early_fragment_tests) in; Depth Pre-Pass The Depth Pre-Pass (also known as Z-Pre-Pass) is an explicit two-pass rendering strategy:\nFirst pass: Render all opaque geometries from front to back writing only to the depth buffer (no color writes, minimal shader). Second pass: Render the same geometries in the same order again, this time using full fragment shading but with depth testing enabled and depth writes disabled. Since the depth buffer now contains the nearest surfaces, most fragments that would be hidden are immediately rejected in the second pass.\nThis ensures that the heavy fragment shaders run only on visible pixels.\nDepending on which render path you are using, the second pass could be a G-buffer pass, a V-Buffer pass, or a lighting pass.\nNOTE Why render in front-to-back order?\nBecause we only care about the nearest visible surfaces.\nBy drawing the objects closer to the camera first, fragments from objects behind them will often fail the depth test and get skipped early, which significantly improves rendering performance.\nAdvantages Greatly reduces shading cost in high overdraw scenes. Consistent performance regardless of scene complexity. Works even when Early-Z is disabled due to complex shaders. Disadvantages Doubles the geometry workload (you render everything twice). May not be worth it for scenes that are vertex-heavy or have low overdraw. Requires good batching to avoid CPU bottlenecks. When to Use Which Scenario Early-Z Depth Pre-Pass Simple opaque materials ‚úÖ Enabled automatically üö´ Not needed Heavy fragment shaders with high overdraw ‚ö†Ô∏è May be disabled ‚úÖ Beneficial Alpha-tested materials (e.g., foliage) üö´ Often disabled ‚ö†Ô∏è Sometimes helpful Deferred rendering path ‚öôÔ∏è Partially effective ‚úÖ Commonly used In modern engines, many rendering pipelines dynamically decide whether to use a Depth Pre-Pass depending on the scene‚Äôs overdraw ratio and shader cost. For example, Unity and Unreal Engine enable it automatically for certain passes like deferred G-buffer generation or shadow casters.\nSummary Early-Z is a hardware feature that automatically skips hidden fragments when possible. Depth Pre-Pass is a manual rendering technique to guarantee that only visible fragments run expensive shaders. Both aim to reduce overdraw, improving frame rate and GPU efficiency. Understanding how and when to leverage these can make a big difference in the performance of your renderer ‚Äî especially in scenes with dense geometry or complex shading pipelines.\nHow did libvultra integrate them Sort all opaque geometries from front to back Depth Pre-Pass: Draw all sorted opaque geometries, only write depth values. G-Buffer Pass: Draw all sorted opaque geometries with Early-Z enabled, depth test only, no depth write. Draw other geometries with Early-Z disabled, depth test + depth write. https://github.com/zzxzzk115/libvultra/commit/2582ba27e27fbd0cc165ba9423b41f972e5affe6\nUseful Links https://wikis.khronos.org/opengl/Early_Fragment_Test ","wordCount":"785","inLanguage":"en","image":"https://zzxzzk115.github.io/new-blog/cover.png","datePublished":"2025-11-08T16:14:06Z","dateModified":"2025-11-08T16:14:06Z","author":{"@type":"Person","name":"Kexuan Zhang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/"},"publisher":{"@type":"Organization","name":"Kexuan Zhang's Blog","logo":{"@type":"ImageObject","url":"https://zzxzzk115.github.io/new-blog/images/favicon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://zzxzzk115.github.io/new-blog/ accesskey=h title="Kexuan Zhang's Blog (Alt + H)"><img src=https://zzxzzk115.github.io/new-blog/images/favicon/apple-touch-icon.png alt aria-label=logo height=35>Kexuan Zhang's Blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://zzxzzk115.github.io/new-blog/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zzxzzk115.github.io/new-blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zzxzzk115.github.io/new-blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zzxzzk115.github.io/new-blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post><header class=post-header><div class=breadcrumbs><a href=https://zzxzzk115.github.io/new-blog/>Home</a>&nbsp;¬ª&nbsp;<a href=https://zzxzzk115.github.io/new-blog/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Depth Pre-Pass and Early-Z</h1><div class=post-meta><span title='2025-11-08 16:14:06 +0000 UTC'>November 8, 2025</span>&nbsp;¬∑&nbsp;<span>4 min</span>&nbsp;¬∑&nbsp;<span>785 words</span>&nbsp;¬∑&nbsp;<span>Kexuan Zhang</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/zzxzzk115/new-blog/content/posts/depth-pre-pass-and-early-z/index.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><figure class=entry-cover><img loading=eager srcset='https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/cover_hu_905987fa50910392.png 360w,https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/cover_hu_e4ae1af2fa0b3062.png 480w,https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/cover_hu_528b086fe6867c22.png 720w,https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/cover_hu_7392f36b5c1a97cc.png 1080w,https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/cover_hu_b105ce5e241a6ce4.png 1500w,https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/cover.png 1536w' src=https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/cover.png sizes="(min-width: 768px) 720px, 100vw" width=1536 height=1024 alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#overdraw aria-label=Overdraw>Overdraw</a></li><li><a href=#the-depth-buffer aria-label="The Depth Buffer">The Depth Buffer</a></li><li><a href=#early-z aria-label=Early-Z>Early-Z</a></li><li><a href=#depth-pre-pass aria-label="Depth Pre-Pass">Depth Pre-Pass</a><ul><li><a href=#advantages aria-label=Advantages>Advantages</a></li><li><a href=#disadvantages aria-label=Disadvantages>Disadvantages</a></li></ul></li><li><a href=#when-to-use-which aria-label="When to Use Which">When to Use Which</a></li><li><a href=#summary aria-label=Summary>Summary</a></li><li><a href=#how-did-libvultra-integrate-them aria-label="How did libvultra integrate them">How did libvultra integrate them</a></li><li><a href=#useful-links aria-label="Useful Links">Useful Links</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><aside id=recent-container class="recent-container wide"><div class=recent><details open><summary><span class=details>Latest Posts</span></summary><div class=inner><div class=recent-post-item><a href=/new-blog/posts/considering-transfering-to-nvidia-render-interface-nri/>Considering Transfering to Nvidia Render Interface (NRI)</a></div><div class=recent-post-item><a href=/new-blog/posts/depth-pre-pass-and-early-z/>Depth Pre-Pass and Early-Z</a></div><div class=recent-post-item><a href=/new-blog/posts/how-to-check-if-godot-is-paused-at-breakpoints/>How to Check if Godot Is Paused at Breakpoints</a></div><div class=recent-post-item><a href=/new-blog/posts/why-hugo/>Why Hugo</a></div><div class=recent-post-item><a href=/new-blog/posts/hugo_confiig/>Hugo PaperMod Customization</a></div></div></details></div></aside><div class=post-content><p>We may have heard of these keywords: <strong>Depth Pre-Pass</strong> and <strong>Early-Z</strong>. But what situations do we actually need them for?</p><h2 id=overdraw>Overdraw<a hidden class=anchor aria-hidden=true href=#overdraw>#</a></h2><p>When rendering a complex 3D scene, multiple fragments may map to the same pixel on the screen ‚Äî for example, when one object is in front of another. The GPU will still execute the fragment shader for each layer of geometry, even though only the nearest fragment is visible in the final image.<br>This redundant work is called <strong>overdraw</strong>.</p><p>Excessive overdraw wastes both <strong>fill rate</strong> and <strong>shader computation</strong> resources, especially in scenes with heavy pixel shading (e.g., complex lighting or post-processing).<br>Minimizing overdraw is one of the key goals of any rendering optimization strategy.</p><h2 id=the-depth-buffer>The Depth Buffer<a hidden class=anchor aria-hidden=true href=#the-depth-buffer>#</a></h2><p>The <strong>depth buffer (Z-buffer)</strong> keeps track of the closest depth value written for each pixel so far.<br>When a new fragment is processed, the GPU compares its depth with the stored value to decide whether it‚Äôs visible (passes the depth test) or hidden (fails the depth test).</p><ul><li>If <strong>Depth Test Passes</strong> ‚Üí the fragment is drawn, and the depth buffer is updated.</li><li>If <strong>Depth Test Fails</strong> ‚Üí the fragment is discarded before writing to the color buffer.</li></ul><p>However, the key question is <strong>when</strong> this depth comparison happens relative to fragment shading ‚Äî and this is where <strong>Early-Z</strong> and <strong>Depth Pre-Pass</strong> come into play.</p><h2 id=early-z>Early-Z<a hidden class=anchor aria-hidden=true href=#early-z>#</a></h2><p>Modern GPUs implement <strong>Early-Z rejection</strong>, meaning the depth test can be performed <strong>before</strong> the fragment shader runs.<br>If a fragment fails the test (i.e., it‚Äôs behind something already drawn), the GPU can skip executing the pixel shader entirely.<br>This saves a huge amount of computation, especially with expensive fragment programs.</p><p>But Early-Z has some caveats:</p><ul><li>It only works if the fragment shader doesn‚Äôt modify the depth value or use discard/alpha-test operations that could change visibility.</li><li>Certain rendering states (e.g., blending, alpha testing) may force the GPU to disable Early-Z to maintain correct visual output.</li></ul><p>In short: <strong>Early-Z works automatically</strong> when your shaders are ‚Äúsimple‚Äù ‚Äî i.e., they don‚Äôt interfere with depth writes or discards.</p><p>To enable Early-Z explicitly in Vulkan, just add one line to your fragment shader:</p><div class=highlight><div style=color:#bbc3d4;background-color:#242933;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#bbc3d4;background-color:#242933;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#5d616a" id=hl-0-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-0-1>1</a>
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#bbc3d4;background-color:#242933;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span>layout<span style=color:#eceff4>(</span>early_fragment_tests<span style=color:#eceff4>)</span> <span style=color:#d08770;font-weight:700>in</span><span style=color:#eceff4>;</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=depth-pre-pass>Depth Pre-Pass<a hidden class=anchor aria-hidden=true href=#depth-pre-pass>#</a></h2><p>The <strong>Depth Pre-Pass</strong> (also known as <strong>Z-Pre-Pass</strong>) is an explicit two-pass rendering strategy:</p><ol><li><strong>First pass:</strong> Render all opaque geometries from front to back <strong>writing only to the depth buffer</strong> (no color writes, minimal shader).</li><li><strong>Second pass:</strong> Render the same geometries in the same order again, this time using full fragment shading but with <strong>depth testing</strong> enabled and <strong>depth writes</strong> disabled.</li></ol><p>Since the depth buffer now contains the nearest surfaces, most fragments that would be hidden are immediately rejected in the second pass.<br>This ensures that the heavy fragment shaders run <strong>only on visible pixels</strong>.</p><p>Depending on which render path you are using, the second pass could be a G-buffer pass, a V-Buffer pass, or a lighting pass.</p><blockquote class="alert-blockquote alert-note"><p class=alert-heading><svg viewBox="0 0 16 16" width="16" height="16"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>
<span>NOTE</span></p><p><strong>Why render in front-to-back order?</strong></p><p>Because we only care about the nearest visible surfaces.<br>By drawing the objects closer to the camera first, fragments from objects behind them will often fail the depth test and get skipped early, which significantly improves rendering performance.</p></blockquote><h3 id=advantages>Advantages<a hidden class=anchor aria-hidden=true href=#advantages>#</a></h3><ul><li>Greatly reduces shading cost in high overdraw scenes.</li><li>Consistent performance regardless of scene complexity.</li><li>Works even when Early-Z is disabled due to complex shaders.</li></ul><h3 id=disadvantages>Disadvantages<a hidden class=anchor aria-hidden=true href=#disadvantages>#</a></h3><ul><li>Doubles the geometry workload (you render everything twice).</li><li>May not be worth it for scenes that are vertex-heavy or have low overdraw.</li><li>Requires good batching to avoid CPU bottlenecks.</li></ul><h2 id=when-to-use-which>When to Use Which<a hidden class=anchor aria-hidden=true href=#when-to-use-which>#</a></h2><table><thead><tr><th>Scenario</th><th>Early-Z</th><th>Depth Pre-Pass</th></tr></thead><tbody><tr><td>Simple opaque materials</td><td>‚úÖ Enabled automatically</td><td>üö´ Not needed</td></tr><tr><td>Heavy fragment shaders with high overdraw</td><td>‚ö†Ô∏è May be disabled</td><td>‚úÖ Beneficial</td></tr><tr><td>Alpha-tested materials (e.g., foliage)</td><td>üö´ Often disabled</td><td>‚ö†Ô∏è Sometimes helpful</td></tr><tr><td>Deferred rendering path</td><td>‚öôÔ∏è Partially effective</td><td>‚úÖ Commonly used</td></tr></tbody></table><p>In modern engines, many rendering pipelines dynamically decide whether to use a Depth Pre-Pass depending on the scene‚Äôs <strong>overdraw ratio</strong> and <strong>shader cost</strong>. For example, Unity and Unreal Engine enable it automatically for certain passes like deferred G-buffer generation or shadow casters.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><ul><li><strong>Early-Z</strong> is a <em>hardware feature</em> that automatically skips hidden fragments <em>when possible</em>.</li><li><strong>Depth Pre-Pass</strong> is a <em>manual rendering technique</em> to guarantee that only visible fragments run expensive shaders.</li><li>Both aim to reduce <strong>overdraw</strong>, improving frame rate and GPU efficiency.</li></ul><p>Understanding how and when to leverage these can make a big difference in the performance of your renderer ‚Äî especially in scenes with dense geometry or complex shading pipelines.</p><h2 id=how-did-libvultra-integrate-them>How did libvultra integrate them<a hidden class=anchor aria-hidden=true href=#how-did-libvultra-integrate-them>#</a></h2><ul><li>Sort all opaque geometries from front to back</li><li>Depth Pre-Pass: Draw all sorted opaque geometries, only write depth values.</li><li>G-Buffer Pass:<ul><li>Draw all sorted opaque geometries with Early-Z enabled, depth test only, no depth write.</li><li>Draw other geometries with Early-Z disabled, depth test + depth write.</li></ul></li></ul><p><a href=https://github.com/zzxzzk115/libvultra/commit/2582ba27e27fbd0cc165ba9423b41f972e5affe6>https://github.com/zzxzzk115/libvultra/commit/2582ba27e27fbd0cc165ba9423b41f972e5affe6</a></p><h2 id=useful-links>Useful Links<a hidden class=anchor aria-hidden=true href=#useful-links>#</a></h2><ul><li><a href=https://wikis.khronos.org/opengl/Early_Fragment_Test>https://wikis.khronos.org/opengl/Early_Fragment_Test</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zzxzzk115.github.io/new-blog/tags/optimization/>Optimization</a></li><li><a href=https://zzxzzk115.github.io/new-blog/tags/render-path/>Render-Path</a></li><li><a href=https://zzxzzk115.github.io/new-blog/tags/depth-pre-pass/>Depth Pre-Pass</a></li><li><a href=https://zzxzzk115.github.io/new-blog/tags/early-z/>Early-Z</a></li></ul><nav class=paginav><a class=prev href=https://zzxzzk115.github.io/new-blog/posts/considering-transfering-to-nvidia-render-interface-nri/><span class=title>¬´ Prev</span><br><span>Considering Transfering to Nvidia Render Interface (NRI)</span>
</a><a class=next href=https://zzxzzk115.github.io/new-blog/posts/how-to-check-if-godot-is-paused-at-breakpoints/><span class=title>Next ¬ª</span><br><span>How to Check if Godot Is Paused at Breakpoints</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=zzxzzk115/new-blog data-repo-id=R_kgDOQPYupQ data-category=Announcements data-category-id=DIC_kwDOQPYupc4CxcXN data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=noborder_dark data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://zzxzzk115.github.io/new-blog/>Kexuan Zhang's Blog</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>