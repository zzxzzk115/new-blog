<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Considering Transfering to Nvidia Render Interface (NRI) | Kexuan Zhang's Blog</title><meta name=keywords content="NRI"><meta name=description content="I recently found NRI and it’s really great. Unlike NVRHI, NRI has a cleaner design and modern Vulkan/DX12-ish low-level APIs. It also supports many modern features with official support, such as DLSS. As a PhD student specialising in VR & HPG, NRI seems to be the best RHI for my needs.

NRI
GitHub link: https://github.com/NVIDIA-RTX/NRI
NRI is a modular, extensible, low-level abstract rendering interface that was designed to support all low-level features of D3D12 and Vulkan GAPIs. At the same time, it aims to simplify usage and reduce the amount of code needed (especially compared with VK)."><meta name=author content="Kexuan Zhang"><link rel=canonical href=https://zzxzzk115.github.io/new-blog/posts/considering-transfering-to-nvidia-render-interface-nri/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/new-blog/assets/css/stylesheet.751a9480deb1fb8cecb5e0002a911746823db643ad4b730657aac9b10615ed03.css integrity="sha256-dRqUgN6x+4zsteAAKpEXRoI9tkOtS3MGV6rJsQYV7QM=" rel="preload stylesheet" as=style><link rel=icon href=https://zzxzzk115.github.io/new-blog/images/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zzxzzk115.github.io/new-blog/images/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zzxzzk115.github.io/new-blog/images/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://zzxzzk115.github.io/new-blog/images/favicon/apple-touch-icon.png><link rel=mask-icon href=https://zzxzzk115.github.io/new-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zzxzzk115.github.io/new-blog/posts/considering-transfering-to-nvidia-render-interface-nri/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><script>MathJax={tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><div class=progress-bar></div><script>document.addEventListener("DOMContentLoaded",()=>{const t=document.querySelector(".progress-bar"),e=()=>{const e=window.innerHeight,n=document.documentElement.scrollHeight-e,s=window.scrollY,o=s/n*100;t.style.width=`${o}%`};window.addEventListener("scroll",e),e()})</script><meta property="og:url" content="https://zzxzzk115.github.io/new-blog/posts/considering-transfering-to-nvidia-render-interface-nri/"><meta property="og:site_name" content="Kexuan Zhang's Blog"><meta property="og:title" content="Considering Transfering to Nvidia Render Interface (NRI)"><meta property="og:description" content="I recently found NRI and it’s really great. Unlike NVRHI, NRI has a cleaner design and modern Vulkan/DX12-ish low-level APIs. It also supports many modern features with official support, such as DLSS. As a PhD student specialising in VR & HPG, NRI seems to be the best RHI for my needs.
NRI GitHub link: https://github.com/NVIDIA-RTX/NRI
NRI is a modular, extensible, low-level abstract rendering interface that was designed to support all low-level features of D3D12 and Vulkan GAPIs. At the same time, it aims to simplify usage and reduce the amount of code needed (especially compared with VK)."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-15T14:32:35+00:00"><meta property="article:modified_time" content="2025-11-15T14:32:35+00:00"><meta property="article:tag" content="NRI"><meta property="og:image" content="https://zzxzzk115.github.io/new-blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zzxzzk115.github.io/new-blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Considering Transfering to Nvidia Render Interface (NRI)"><meta name=twitter:description content="I recently found NRI and it’s really great. Unlike NVRHI, NRI has a cleaner design and modern Vulkan/DX12-ish low-level APIs. It also supports many modern features with official support, such as DLSS. As a PhD student specialising in VR & HPG, NRI seems to be the best RHI for my needs.

NRI
GitHub link: https://github.com/NVIDIA-RTX/NRI
NRI is a modular, extensible, low-level abstract rendering interface that was designed to support all low-level features of D3D12 and Vulkan GAPIs. At the same time, it aims to simplify usage and reduce the amount of code needed (especially compared with VK)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zzxzzk115.github.io/new-blog/posts/"},{"@type":"ListItem","position":2,"name":"Considering Transfering to Nvidia Render Interface (NRI)","item":"https://zzxzzk115.github.io/new-blog/posts/considering-transfering-to-nvidia-render-interface-nri/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Considering Transfering to Nvidia Render Interface (NRI)","name":"Considering Transfering to Nvidia Render Interface (NRI)","description":"I recently found NRI and it’s really great. Unlike NVRHI, NRI has a cleaner design and modern Vulkan/DX12-ish low-level APIs. It also supports many modern features with official support, such as DLSS. As a PhD student specialising in VR \u0026amp; HPG, NRI seems to be the best RHI for my needs.\nNRI GitHub link: https://github.com/NVIDIA-RTX/NRI\nNRI is a modular, extensible, low-level abstract rendering interface that was designed to support all low-level features of D3D12 and Vulkan GAPIs. At the same time, it aims to simplify usage and reduce the amount of code needed (especially compared with VK).\n","keywords":["NRI"],"articleBody":"I recently found NRI and it’s really great. Unlike NVRHI, NRI has a cleaner design and modern Vulkan/DX12-ish low-level APIs. It also supports many modern features with official support, such as DLSS. As a PhD student specialising in VR \u0026 HPG, NRI seems to be the best RHI for my needs.\nNRI GitHub link: https://github.com/NVIDIA-RTX/NRI\nNRI is a modular, extensible, low-level abstract rendering interface that was designed to support all low-level features of D3D12 and Vulkan GAPIs. At the same time, it aims to simplify usage and reduce the amount of code needed (especially compared with VK).\nGoals:\nGeneralization and unification of D3D12 (spec) and VK (spec) Explicitness (providing access to low-level features of modern GAPIs) Quality-of-life and high-level extensions (e.g., streaming and upscaling) Low overhead Cross-platform and platform independence (AMD/INTEL friendly) D3D11 support (spec) (as much as possible) Non-goals:\nExposing entities not existing in GAPIs High-level (D3D11-like) abstraction Hidden management of any kind (except for some high-level extensions where it’s desired) Automatic barriers (better handled in a higher-level abstraction) Supported GAPIs:\nVulkan D3D12 D3D11 Metal (through MoltenVK) None / dummy (everything is supported but does nothing) Required Vulkan extensions: for Vulkan \u003c 1.3: VK_KHR_synchronization2 VK_KHR_dynamic_rendering VK_KHR_copy_commands2 VK_KHR_maintenance4 (optional, but recommended) VK_EXT_extended_dynamic_state for Vulkan \u003c 1.4: _VK_KHR_push_descriptor _VK_KHR_maintenance5 (optional, but recommended) _VK_KHR_maintenance6 (optional, but recommended) for APPLE: VK_KHR_portability_enumeration (instance extension) VK_KHR_get_physical_device_properties2 (instance extension) VK_KHR_portability_subset Supported Vulkan extensions: Instance: VK_KHR_get_surface_capabilities2 VK_KHR_surface VK_KHR_win32_surface (VK_KHR_xlib_surface, VK_KHR_wayland_surface, VK_EXT_metal_surface) VK_EXT_swapchain_colorspace VK_EXT_debug_utils Device: VK_KHR_swapchain VK_KHR_present_id VK_KHR_present_wait VK_KHR_swapchain_mutable_format VK_KHR_maintenance7 VK_KHR_maintenance8 VK_KHR_maintenance9 VK_KHR_fragment_shading_rate VK_KHR_pipeline_library VK_KHR_ray_tracing_pipeline VK_KHR_acceleration_structure (depends on VK_KHR_deferred_host_operations) VK_KHR_ray_query VK_KHR_ray_tracing_position_fetch VK_KHR_ray_tracing_maintenance1 VK_KHR_line_rasterization VK_KHR_fragment_shader_barycentric VK_KHR_shader_clock VK_KHR_compute_shader_derivatives VK_EXT_mutable_descriptor_type VK_EXT_subgroup_size_control VK_EXT_swapchain_maintenance1 VK_EXT_present_mode_fifo_latest_ready VK_EXT_opacity_micromap VK_EXT_sample_locations VK_EXT_conservative_rasterization VK_EXT_mesh_shader VK_EXT_shader_atomic_float VK_EXT_shader_atomic_float2 VK_EXT_memory_budget VK_EXT_memory_priority VK_EXT_image_sliced_view_of_3d VK_EXT_custom_border_color VK_EXT_image_robustness VK_EXT_robustness2 VK_EXT_pipeline_robustness VK_EXT_fragment_shader_interlock VK_NV_low_latency2 VK_NVX_binary_import VK_NVX_image_view_handle Requirement OpenXR Multi-view Raytracing Mesh Shaders Wayland Before I start coding, I need to make sure that it is possible to make it work with OpenXR SDK.\nFortunately, it supports both Vulkan and DX12 which means it should work with OpenXR.\nNext, I need to check whether it supports multi-view, because that’s the baseline for many VR applications.\nI notices that they do support Multi-View but VK_KHR_multiview is not listed in the README.md. Check out this issue: https://github.com/NVIDIA-RTX/NRI/issues/42\nFinally, it should support real-time ray tracing and mesh shaders, and it does (^_^).\nWhat about running it on an AMD GPU machine with Linux and Wayland? Currently, no. X11? Yes. However, I believe that support for Wayland will be added in the future.\nWhy not just Vulkan or DX12 Since I’m using NVIDIA’s techniques, it would be better to use their official, more powerful SDK. It can also save me time when it comes to integrating DLSS, FSR and similar features.\nStill experimental Although it’s great, it has some limitations. For example, we can’t add a Vulkan extension directly; we have to consider the equivalent in DX12 instead. Fortunately, it’s a community-driven project, which means that others can contribute extensions and features to strengthen it. Its ability is sufficient for my studies for now.\n","wordCount":"492","inLanguage":"en","image":"https://zzxzzk115.github.io/new-blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-11-15T14:32:35Z","dateModified":"2025-11-15T14:32:35Z","author":{"@type":"Person","name":"Kexuan Zhang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zzxzzk115.github.io/new-blog/posts/considering-transfering-to-nvidia-render-interface-nri/"},"publisher":{"@type":"Organization","name":"Kexuan Zhang's Blog","logo":{"@type":"ImageObject","url":"https://zzxzzk115.github.io/new-blog/images/favicon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://zzxzzk115.github.io/new-blog/ accesskey=h title="Kexuan Zhang's Blog (Alt + H)"><img src=https://zzxzzk115.github.io/new-blog/images/favicon/apple-touch-icon.png alt aria-label=logo height=35>Kexuan Zhang's Blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://zzxzzk115.github.io/new-blog/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zzxzzk115.github.io/new-blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zzxzzk115.github.io/new-blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zzxzzk115.github.io/new-blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post><header class=post-header><div class=breadcrumbs><a href=https://zzxzzk115.github.io/new-blog/>Home</a>&nbsp;»&nbsp;<a href=https://zzxzzk115.github.io/new-blog/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Considering Transfering to Nvidia Render Interface (NRI)</h1><div class=post-meta><span title='2025-11-15 14:32:35 +0000 UTC'>November 15, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>492 words</span>&nbsp;·&nbsp;<span>Kexuan Zhang</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/zzxzzk115/new-blog/content/posts/considering-transfering-to-nvidia-render-interface-%28nri%29.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#nri aria-label=NRI>NRI</a></li><li><a href=#requirement aria-label=Requirement>Requirement</a></li><li><a href=#why-not-just-vulkan-or-dx12 aria-label="Why not just Vulkan or DX12">Why not just Vulkan or DX12</a></li><li><a href=#still-experimental aria-label="Still experimental">Still experimental</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><aside id=recent-container class="recent-container wide"><div class=recent><details open><summary><span class=details>Latest Posts</span></summary><div class=inner><div class=recent-post-item><a href=/new-blog/posts/trackpoint-is-dead-after-resuming/>TrackPoint is Dead after Resuming?</a></div><div class=recent-post-item><a href=/new-blog/posts/considering-transfering-to-nvidia-render-interface-nri/>Considering Transfering to Nvidia Render Interface (NRI)</a></div><div class=recent-post-item><a href=/new-blog/posts/depth-pre-pass-and-early-z/>Depth Pre-Pass and Early-Z</a></div><div class=recent-post-item><a href=/new-blog/posts/how-to-check-if-godot-is-paused-at-breakpoints/>How to Check if Godot Is Paused at Breakpoints</a></div><div class=recent-post-item><a href=/new-blog/posts/why-hugo/>Why Hugo</a></div></div></details></div></aside><div class=post-content><p>I recently found NRI and it’s really great. Unlike NVRHI, NRI has a cleaner design and modern Vulkan/DX12-ish low-level APIs. It also supports many modern features with official support, such as DLSS. As a PhD student specialising in VR & HPG, NRI seems to be the best RHI for my needs.</p><h2 id=nri>NRI<a hidden class=anchor aria-hidden=true href=#nri>#</a></h2><p>GitHub link: <a href=https://github.com/NVIDIA-RTX/NRI>https://github.com/NVIDIA-RTX/NRI</a></p><p><em>NRI</em> is a modular, extensible, low-level abstract rendering interface that was designed to support all low-level features of D3D12 and Vulkan GAPIs. At the same time, it aims to simplify usage and reduce the amount of code needed (especially compared with VK).</p><p>Goals:</p><ul><li>Generalization and unification of D3D12 (<a href=https://microsoft.github.io/DirectX-Specs/>spec</a>) and VK (<a href=https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html>spec</a>)</li><li>Explicitness (providing access to low-level features of modern GAPIs)</li><li>Quality-of-life and high-level extensions (e.g., streaming and upscaling)</li><li>Low overhead</li><li>Cross-platform and platform independence (AMD/INTEL friendly)</li><li>D3D11 support (<a href=https://microsoft.github.io/DirectX-Specs/d3d/archive/D3D11_3_FunctionalSpec.htm>spec</a>) (as much as possible)</li></ul><p>Non-goals:</p><ul><li>Exposing entities not existing in GAPIs</li><li>High-level (D3D11-like) abstraction</li><li>Hidden management of any kind (except for some high-level extensions where it&rsquo;s desired)</li><li>Automatic barriers (better handled in a higher-level abstraction)</li></ul><p>Supported GAPIs:</p><ul><li>Vulkan</li><li>D3D12</li><li>D3D11</li><li>Metal (through <a href=https://github.com/KhronosGroup/MoltenVK>MoltenVK</a>)</li><li>None / dummy (everything is supported but does nothing)</li></ul><details><summary>Required Vulkan extensions:</summary><ul><li>for Vulkan &lt; 1.3:<ul><li><em>VK_KHR_synchronization2</em></li><li><em>VK_KHR_dynamic_rendering</em></li><li><em>VK_KHR_copy_commands2</em></li><li><em>VK_KHR_maintenance4</em> (optional, but recommended)</li><li><em>VK_EXT_extended_dynamic_state</em></li></ul></li><li>for Vulkan &lt; 1.4:<ul><li>_VK_KHR_push_descriptor</li><li>_VK_KHR_maintenance5 (optional, but recommended)</li><li>_VK_KHR_maintenance6 (optional, but recommended)</li></ul></li><li>for APPLE:<ul><li><em>VK_KHR_portability_enumeration</em> (instance extension)</li><li><em>VK_KHR_get_physical_device_properties2</em> (instance extension)</li><li><em>VK_KHR_portability_subset</em></li></ul></li></ul></details><details><summary>Supported Vulkan extensions:</summary><ul><li>Instance:<ul><li><em>VK_KHR_get_surface_capabilities2</em></li><li><em>VK_KHR_surface</em></li><li><em>VK_KHR_win32_surface</em> (<em>VK_KHR_xlib_surface</em>, <em>VK_KHR_wayland_surface</em>, <em>VK_EXT_metal_surface</em>)</li><li><em>VK_EXT_swapchain_colorspace</em></li><li><em>VK_EXT_debug_utils</em></li></ul></li><li>Device:<ul><li><em>VK_KHR_swapchain</em></li><li><em>VK_KHR_present_id</em></li><li><em>VK_KHR_present_wait</em></li><li><em>VK_KHR_swapchain_mutable_format</em></li><li><em>VK_KHR_maintenance7</em></li><li><em>VK_KHR_maintenance8</em></li><li><em>VK_KHR_maintenance9</em></li><li><em>VK_KHR_fragment_shading_rate</em></li><li><em>VK_KHR_pipeline_library</em></li><li><em>VK_KHR_ray_tracing_pipeline</em></li><li><em>VK_KHR_acceleration_structure</em> (depends on <em>VK_KHR_deferred_host_operations</em>)</li><li><em>VK_KHR_ray_query</em></li><li><em>VK_KHR_ray_tracing_position_fetch</em></li><li><em>VK_KHR_ray_tracing_maintenance1</em></li><li><em>VK_KHR_line_rasterization</em></li><li><em>VK_KHR_fragment_shader_barycentric</em></li><li><em>VK_KHR_shader_clock</em></li><li><em>VK_KHR_compute_shader_derivatives</em></li><li><em>VK_EXT_mutable_descriptor_type</em></li><li><em>VK_EXT_subgroup_size_control</em></li><li><em>VK_EXT_swapchain_maintenance1</em></li><li><em>VK_EXT_present_mode_fifo_latest_ready</em></li><li><em>VK_EXT_opacity_micromap</em></li><li><em>VK_EXT_sample_locations</em></li><li><em>VK_EXT_conservative_rasterization</em></li><li><em>VK_EXT_mesh_shader</em></li><li><em>VK_EXT_shader_atomic_float</em></li><li><em>VK_EXT_shader_atomic_float2</em></li><li><em>VK_EXT_memory_budget</em></li><li><em>VK_EXT_memory_priority</em></li><li><em>VK_EXT_image_sliced_view_of_3d</em></li><li><em>VK_EXT_custom_border_color</em></li><li><em>VK_EXT_image_robustness</em></li><li><em>VK_EXT_robustness2</em></li><li><em>VK_EXT_pipeline_robustness</em></li><li><em>VK_EXT_fragment_shader_interlock</em></li><li><em>VK_NV_low_latency2</em></li><li><em>VK_NVX_binary_import</em></li><li><em>VK_NVX_image_view_handle</em></li></ul></li></ul></details><h2 id=requirement>Requirement<a hidden class=anchor aria-hidden=true href=#requirement>#</a></h2><ul><li><input checked disabled type=checkbox> OpenXR</li><li><input checked disabled type=checkbox> Multi-view</li><li><input checked disabled type=checkbox> Raytracing</li><li><input checked disabled type=checkbox> Mesh Shaders</li><li><input disabled type=checkbox> Wayland</li></ul><p>Before I start coding, I need to make sure that it is possible to make it work with OpenXR SDK.</p><p>Fortunately, it supports both Vulkan and DX12 which means it should work with OpenXR.</p><p>Next, I need to check whether it supports multi-view, because that’s the baseline for many VR applications.</p><p>I notices that they do support Multi-View but VK_KHR_multiview is not listed in the README.md. Check out this issue: <a href=https://github.com/NVIDIA-RTX/NRI/issues/42>https://github.com/NVIDIA-RTX/NRI/issues/42</a></p><p>Finally, it should support real-time ray tracing and mesh shaders, and it does (^_^).</p><p>What about running it on an AMD GPU machine with Linux and Wayland? Currently, no. X11? Yes. However, I believe that support for Wayland will be added in the future.</p><h2 id=why-not-just-vulkan-or-dx12>Why not just Vulkan or DX12<a hidden class=anchor aria-hidden=true href=#why-not-just-vulkan-or-dx12>#</a></h2><p>Since I’m using NVIDIA&rsquo;s techniques, it would be better to use their official, more powerful SDK. It can also save me time when it comes to integrating DLSS, FSR and similar features.</p><h2 id=still-experimental>Still experimental<a hidden class=anchor aria-hidden=true href=#still-experimental>#</a></h2><p>Although it’s great, it has some limitations. For example, we can’t add a Vulkan extension directly; we have to consider the equivalent in DX12 instead. Fortunately, it’s a community-driven project, which means that others can contribute extensions and features to strengthen it. Its ability is sufficient for my studies for now.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zzxzzk115.github.io/new-blog/tags/nri/>NRI</a></li></ul><nav class=paginav><a class=prev href=https://zzxzzk115.github.io/new-blog/posts/trackpoint-is-dead-after-resuming/><span class=title>« Prev</span><br><span>TrackPoint is Dead after Resuming?</span>
</a><a class=next href=https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/><span class=title>Next »</span><br><span>Depth Pre-Pass and Early-Z</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=zzxzzk115/new-blog data-repo-id=R_kgDOQPYupQ data-category=Announcements data-category-id=DIC_kwDOQPYupc4CxcXN data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=noborder_dark data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://zzxzzk115.github.io/new-blog/>Kexuan Zhang's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>