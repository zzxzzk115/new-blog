[{"content":"We may have heard of these keywords: Depth Pre-Pass and Early-Z. But what situations do we actually need them for?\nOverdraw When rendering a complex 3D scene, multiple fragments may map to the same pixel on the screen ‚Äî for example, when one object is in front of another. The GPU will still execute the fragment shader for each layer of geometry, even though only the nearest fragment is visible in the final image.\nThis redundant work is called overdraw.\nExcessive overdraw wastes both fill rate and shader computation resources, especially in scenes with heavy pixel shading (e.g., complex lighting or post-processing).\nMinimizing overdraw is one of the key goals of any rendering optimization strategy.\nThe Depth Buffer The depth buffer (Z-buffer) keeps track of the closest depth value written for each pixel so far.\nWhen a new fragment is processed, the GPU compares its depth with the stored value to decide whether it‚Äôs visible (passes the depth test) or hidden (fails the depth test).\nIf Depth Test Passes ‚Üí the fragment is drawn, and the depth buffer is updated. If Depth Test Fails ‚Üí the fragment is discarded before writing to the color buffer. However, the key question is when this depth comparison happens relative to fragment shading ‚Äî and this is where Early-Z and Depth Pre-Pass come into play.\nEarly-Z Modern GPUs implement Early-Z rejection, meaning the depth test can be performed before the fragment shader runs.\nIf a fragment fails the test (i.e., it‚Äôs behind something already drawn), the GPU can skip executing the pixel shader entirely.\nThis saves a huge amount of computation, especially with expensive fragment programs.\nBut Early-Z has some caveats:\nIt only works if the fragment shader doesn‚Äôt modify the depth value or use discard/alpha-test operations that could change visibility. Certain rendering states (e.g., blending, alpha testing) may force the GPU to disable Early-Z to maintain correct visual output. In short: Early-Z works automatically when your shaders are ‚Äúsimple‚Äù ‚Äî i.e., they don‚Äôt interfere with depth writes or discards.\nTo enable Early-Z explicitly in Vulkan, just add one line to your fragment shader:\n1 layout(early_fragment_tests) in; Depth Pre-Pass The Depth Pre-Pass (also known as Z-Pre-Pass) is an explicit two-pass rendering strategy:\nFirst pass: Render all opaque geometries from front to back writing only to the depth buffer (no color writes, minimal shader). Second pass: Render the same geometries in the same order again, this time using full fragment shading but with depth testing enabled and depth writes disabled. Since the depth buffer now contains the nearest surfaces, most fragments that would be hidden are immediately rejected in the second pass.\nThis ensures that the heavy fragment shaders run only on visible pixels.\nNOTE Why render in front-to-back order?\nBecause we only care about the nearest visible surfaces.\nBy drawing the objects closer to the camera first, fragments from objects behind them will often fail the depth test and get skipped early, which significantly improves rendering performance.\nAdvantages Greatly reduces shading cost in high overdraw scenes. Consistent performance regardless of scene complexity. Works even when Early-Z is disabled due to complex shaders. Disadvantages Doubles the geometry workload (you render everything twice). May not be worth it for scenes that are vertex-heavy or have low overdraw. Requires good batching to avoid CPU bottlenecks. When to Use Which Scenario Early-Z Depth Pre-Pass Simple opaque materials ‚úÖ Enabled automatically üö´ Not needed Heavy fragment shaders with high overdraw ‚ö†Ô∏è May be disabled ‚úÖ Beneficial Alpha-tested materials (e.g., foliage) üö´ Often disabled ‚ö†Ô∏è Sometimes helpful Deferred rendering path ‚öôÔ∏è Partially effective ‚úÖ Commonly used In modern engines, many rendering pipelines dynamically decide whether to use a Depth Pre-Pass depending on the scene‚Äôs overdraw ratio and shader cost. For example, Unity and Unreal Engine enable it automatically for certain passes like deferred G-buffer generation or shadow casters.\nSummary Early-Z is a hardware feature that automatically skips hidden fragments when possible. Depth Pre-Pass is a manual rendering technique to guarantee that only visible fragments run expensive shaders. Both aim to reduce overdraw, improving frame rate and GPU efficiency. Understanding how and when to leverage these can make a big difference in the performance of your renderer ‚Äî especially in scenes with dense geometry or complex shading pipelines.\nHow did libvultra integrate them Sort all opaque geometries from front to back Depth Pre-Pass G-Buffer Pass: Draw all sorted opaque geometries with Early-Z enabled, depth test only, no depth write. Draw other geometries with Early-Z disabled, depth test + depth write. https://github.com/zzxzzk115/libvultra/commit/2582ba27e27fbd0cc165ba9423b41f972e5affe6\nUseful Links https://wikis.khronos.org/opengl/Early_Fragment_Test ","permalink":"https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/","summary":"\u003cp\u003eWe may have heard of these keywords: \u003cstrong\u003eDepth Pre-Pass\u003c/strong\u003e and \u003cstrong\u003eEarly-Z\u003c/strong\u003e. But what situations do we actually need them for?\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"overdraw\"\u003eOverdraw\u003c/h2\u003e\n\u003cp\u003eWhen rendering a complex 3D scene, multiple fragments may map to the same pixel on the screen ‚Äî for example, when one object is in front of another. The GPU will still execute the fragment shader for each layer of geometry, even though only the nearest fragment is visible in the final image.\u003cbr\u003e\nThis redundant work is called \u003cstrong\u003eoverdraw\u003c/strong\u003e.\u003c/p\u003e","title":"Depth Pre-Pass and Early-Z"},{"content":"Problem Statement We need to check whether Godot pauses at breakpoints. However, Godot does not provide a direct API for this.\nThe Tricky Way If the program pauses at a breakpoint, the engine\u0026rsquo;s timer also pauses and we can check the delta time inside a _process function.\nIf now_tick - last_tick \u0026gt; PAUSE_THRESHOLD, this may be because the program has paused at breakpoints.\nThe DebugHelper class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # DebugHelper.gd extends Node var last_pause_duration: float = 0.0 var _last_ticks_time: float = 0.0 const PAUSE_THRESHOLD := 1.0 func _ready() -\u0026gt; void: process_mode = Node.PROCESS_MODE_ALWAYS _last_ticks_time = Time.get_ticks_msec() / 1000.0 func _process(_delta: float) -\u0026gt; void: var tick_now := Time.get_ticks_msec() / 1000.0 var tick_diff := tick_now - _last_ticks_time # Possible if tick_diff \u0026gt; PAUSE_THRESHOLD: last_pause_duration = tick_diff print(\u0026#34;[DebugHelper] Detected possible debug pause:\u0026#34;, last_pause_duration, \u0026#34;seconds\u0026#34;) # Emit events if you need _last_ticks_time = tick_now It could be an AutoLoad script. Alternatively, you can use signals or your custom event system to notify other systems when it detects potential debug pauses.\n","permalink":"https://zzxzzk115.github.io/new-blog/posts/how-to-check-if-godot-is-paused-at-breakpoints/","summary":"How to check if Godot is paused at breakpoints in a tricky way?","title":"How to Check if Godot Is Paused at Breakpoints"},{"content":"I‚Äôve tried both Hexo and VuePress, and they are both good static site generators. However, they both rely on Node.js, which is annoying. I have to worry about dependencies.\nUsing Hugo is much simpler. Just install it and everything works well with no dependencies. Also, you don\u0026rsquo;t need admin permission to install it.\nAbove all, I don‚Äôt need powerful or beautiful features for my blog. All I want is a simple design.\n","permalink":"https://zzxzzk115.github.io/new-blog/posts/why-hugo/","summary":"Why Hugo? Why not VuePress / Hexo?","title":"Why Hugo"},{"content":"Step 1 Create layouts/partials/extend_head.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 {{ if or .Params.math .Site.Params.math }} \u0026lt;script\u0026gt; MathJax = { tex: { inlineMath: [[\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;], [\u0026#39;$\u0026#39;, \u0026#39;$\u0026#39;]], displayMath: [[\u0026#39;$$\u0026#39;, \u0026#39;$$\u0026#39;], [\u0026#39;\\\\[\u0026#39;, \u0026#39;\\\\]\u0026#39;]], processEscapes: true, processEnvironments: true }, options: { skipHtmlTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;] } }; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://polyfill.io/v3/polyfill.min.js?features=es6\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} Step 2 Create layouts/_default/baseof.html:\n1 {{ partial \u0026#34;extend-head.html\u0026#34; . }} Step 3 Edit hugo.yaml, add markup-\u0026gt;goldmark section and enable math:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 markup: goldmark: renderer: unsafe: true extensions: passthrough: delimiters: block: - - \\[ - \\] - - $$ - $$ inline: - - \\( - \\) - - $ - $ enable: true params: math: true ","permalink":"https://zzxzzk115.github.io/new-blog/posts/hugo_math/","summary":"How to enable Mathjax for Hugo (PaperMod)? Here are the instructions.","title":"Enable Mathjax for Hugo"},{"content":"Mathjax Test Inline Equations This is an inline \\(a^*=x-b^*\\) equation.\nBlock Equations These are block equations:\n\\[a^*=x-b^*\\]\\[ a^*=x-b^* \\]\\[ a^*=x-b^* \\]These are also block equations:\n$$a^*=x-b^*$$$$ a^*=x-b^* $$$$ a^*=x-b^* $$Example The Rendering Equation:\n\\[ L_o(\\mathbf{x}, \\omega_o) = L_e(\\mathbf{x}, \\omega_o) + \\int_{\\Omega} f_r(\\mathbf{x}, \\omega_i, \\omega_o) \\, L_i(\\mathbf{x}, \\omega_i) \\, (\\omega_i \\cdot \\mathbf{n}) \\, d\\omega_i \\]Code Test 1#include \u0026lt;bits/stdc++.h\u0026gt; 2 3using namespace std; 4 5enum class Color { Red, Green, Blue }; 6 7struct Vec3 { 8 float x{}, y{}, z{}; 9 Vec3 operator+(const Vec3\u0026amp; o) const { return {x + o.x, y + o.y, z + o.z}; } 10}; 11 12int main() { 13 try { 14 vector\u0026lt;Vec3\u0026gt; points{{1,2,3}, {4,5,6}}; 15 auto add = [](Vec3 a, Vec3 b){ return a + b; }; 16 Vec3 sum = add(points[0], points[1]); 17 cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2); 18 cout \u0026lt;\u0026lt; \u0026#34;Sum: (\u0026#34; \u0026lt;\u0026lt; sum.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; sum.y \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; sum.z \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; 19 20 Color c = Color::Green; 21 if (c == Color::Green) 22 cout \u0026lt;\u0026lt; \u0026#34;It\u0026#39;s green!\\n\u0026#34;; 23 } catch (const exception\u0026amp; e) { 24 cerr \u0026lt;\u0026lt; \u0026#34;Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; 25 } 26} Image Test This is an image from /static/images/\nThis is a test image This is an image in the same directory as this markdown source file.\nThis is a test image \u0026lt;iframe\u0026gt;Test Alert CAUTION Content\nIMPORTANT Content\nNOTE Content\nTIP Content\nWARNING Content\n","permalink":"https://zzxzzk115.github.io/new-blog/posts/essential_test/","summary":"Essential test for blog post writting.","title":"Essential Test"}]