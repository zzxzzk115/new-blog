[{"content":"If you are using ThinkPad 51nb\u0026rsquo;s X210 with Arch Linux and Hyprland, you might have the problem that the TrackPoint is not working after resuming from sleeping.\nWhy the TrackPoint doesn\u0026rsquo;t work after resuming It\u0026rsquo;s the firmware problem. The TrackPoint won\u0026rsquo;t properly wake up from sleep mode.\nWorkaround Temporally, you can use two lines of commands to restart the TrackPoint:\n1 2 sudo modprobe -r psmouse sudo modprobe psmouse resetafter=0 If you don\u0026rsquo;t want to type those commands before closing the lid and after opening the lid, you can write a system daemon script:\n1 sudo nano /usr/lib/systemd/system-sleep/psmouse-reset Edit it:\n1 2 3 4 5 6 7 8 9 10 11 #!/bin/sh case $1 in pre) # Before sleep: unload psmouse to avoid corruption modprobe -r psmouse ;; post) # After resume: reload with correct options modprobe psmouse resetafter=0 ;; esac Save it and make it runnable:\n1 sudo chmod +x /usr/lib/systemd/system-sleep/psmouse-reset Reboot! Everytime you resume from sleep mode, the TrackPoint will restart, it takes a few seconds but it works!\n","permalink":"https://zzxzzk115.github.io/new-blog/posts/trackpoint-is-dead-after-resuming/","summary":"\u003cp\u003eIf you are using ThinkPad 51nb\u0026rsquo;s X210 with Arch Linux and Hyprland, you might have the problem that the TrackPoint is not working after resuming from sleeping.\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"why-the-trackpoint-doesnt-work-after-resuming\"\u003eWhy the TrackPoint doesn\u0026rsquo;t work after resuming\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s the firmware problem. The TrackPoint won\u0026rsquo;t properly \u003cem\u003ewake up\u003c/em\u003e from sleep mode.\u003c/p\u003e\n\u003ch2 id=\"workaround\"\u003eWorkaround\u003c/h2\u003e\n\u003cp\u003eTemporally, you can use two lines of commands to restart the TrackPoint:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#bbc3d4;background-color:#242933;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#bbc3d4;background-color:#242933;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#5d616a\" id=\"hl-0-1\"\u003e\u003ca style=\"outline:none;text-decoration:none;color:inherit\" href=\"#hl-0-1\"\u003e1\u003c/a\u003e\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#5d616a\" id=\"hl-0-2\"\u003e\u003ca style=\"outline:none;text-decoration:none;color:inherit\" href=\"#hl-0-2\"\u003e2\u003c/a\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#bbc3d4;background-color:#242933;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo modprobe -r psmouse\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo modprobe psmouse resetafter\u003cspan style=\"color:#5e81ac\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eIf you don\u0026rsquo;t want to type those commands before closing the lid and after opening the lid, you can write a system daemon script:\u003c/p\u003e","title":"TrackPoint is Dead after Resuming?"},{"content":"I recently found NRI and it‚Äôs really great. Unlike NVRHI, NRI has a cleaner design and modern Vulkan/DX12-ish low-level APIs. It also supports many modern features with official support, such as DLSS. As a PhD student specialising in VR \u0026amp; HPG, NRI seems to be the best RHI for my needs.\nNRI GitHub link: https://github.com/NVIDIA-RTX/NRI\nNRI is a modular, extensible, low-level abstract rendering interface that was designed to support all low-level features of D3D12 and Vulkan GAPIs. At the same time, it aims to simplify usage and reduce the amount of code needed (especially compared with VK).\nGoals:\nGeneralization and unification of D3D12 (spec) and VK (spec) Explicitness (providing access to low-level features of modern GAPIs) Quality-of-life and high-level extensions (e.g., streaming and upscaling) Low overhead Cross-platform and platform independence (AMD/INTEL friendly) D3D11 support (spec) (as much as possible) Non-goals:\nExposing entities not existing in GAPIs High-level (D3D11-like) abstraction Hidden management of any kind (except for some high-level extensions where it\u0026rsquo;s desired) Automatic barriers (better handled in a higher-level abstraction) Supported GAPIs:\nVulkan D3D12 D3D11 Metal (through MoltenVK) None / dummy (everything is supported but does nothing) Required Vulkan extensions: for Vulkan \u0026lt; 1.3: VK_KHR_synchronization2 VK_KHR_dynamic_rendering VK_KHR_copy_commands2 VK_KHR_maintenance4 (optional, but recommended) VK_EXT_extended_dynamic_state for Vulkan \u0026lt; 1.4: _VK_KHR_push_descriptor _VK_KHR_maintenance5 (optional, but recommended) _VK_KHR_maintenance6 (optional, but recommended) for APPLE: VK_KHR_portability_enumeration (instance extension) VK_KHR_get_physical_device_properties2 (instance extension) VK_KHR_portability_subset Supported Vulkan extensions: Instance: VK_KHR_get_surface_capabilities2 VK_KHR_surface VK_KHR_win32_surface (VK_KHR_xlib_surface, VK_KHR_wayland_surface, VK_EXT_metal_surface) VK_EXT_swapchain_colorspace VK_EXT_debug_utils Device: VK_KHR_swapchain VK_KHR_present_id VK_KHR_present_wait VK_KHR_swapchain_mutable_format VK_KHR_maintenance7 VK_KHR_maintenance8 VK_KHR_maintenance9 VK_KHR_fragment_shading_rate VK_KHR_pipeline_library VK_KHR_ray_tracing_pipeline VK_KHR_acceleration_structure (depends on VK_KHR_deferred_host_operations) VK_KHR_ray_query VK_KHR_ray_tracing_position_fetch VK_KHR_ray_tracing_maintenance1 VK_KHR_line_rasterization VK_KHR_fragment_shader_barycentric VK_KHR_shader_clock VK_KHR_compute_shader_derivatives VK_EXT_mutable_descriptor_type VK_EXT_subgroup_size_control VK_EXT_swapchain_maintenance1 VK_EXT_present_mode_fifo_latest_ready VK_EXT_opacity_micromap VK_EXT_sample_locations VK_EXT_conservative_rasterization VK_EXT_mesh_shader VK_EXT_shader_atomic_float VK_EXT_shader_atomic_float2 VK_EXT_memory_budget VK_EXT_memory_priority VK_EXT_image_sliced_view_of_3d VK_EXT_custom_border_color VK_EXT_image_robustness VK_EXT_robustness2 VK_EXT_pipeline_robustness VK_EXT_fragment_shader_interlock VK_NV_low_latency2 VK_NVX_binary_import VK_NVX_image_view_handle Requirement OpenXR Multi-view Raytracing Mesh Shaders Wayland Before I start coding, I need to make sure that it is possible to make it work with OpenXR SDK.\nFortunately, it supports both Vulkan and DX12 which means it should work with OpenXR.\nNext, I need to check whether it supports multi-view, because that‚Äôs the baseline for many VR applications.\nI notices that they do support Multi-View but VK_KHR_multiview is not listed in the README.md. Check out this issue: https://github.com/NVIDIA-RTX/NRI/issues/42\nFinally, it should support real-time ray tracing and mesh shaders, and it does (^_^).\nWhat about running it on an AMD GPU machine with Linux and Wayland? Currently, no. X11? Yes. However, I believe that support for Wayland will be added in the future.\nWhy not just Vulkan or DX12 Since I‚Äôm using NVIDIA\u0026rsquo;s techniques, it would be better to use their official, more powerful SDK. It can also save me time when it comes to integrating DLSS, FSR and similar features.\nStill experimental Although it‚Äôs great, it has some limitations. For example, we can‚Äôt add a Vulkan extension directly; we have to consider the equivalent in DX12 instead. Fortunately, it‚Äôs a community-driven project, which means that others can contribute extensions and features to strengthen it. Its ability is sufficient for my studies for now.\n","permalink":"https://zzxzzk115.github.io/new-blog/posts/considering-transfering-to-nvidia-render-interface-nri/","summary":"\u003cp\u003eI recently found NRI and it‚Äôs really great. Unlike NVRHI, NRI has a cleaner design and modern Vulkan/DX12-ish low-level APIs. It also supports many modern features with official support, such as DLSS. As a PhD student specialising in VR \u0026amp; HPG, NRI seems to be the best RHI for my needs.\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"nri\"\u003eNRI\u003c/h2\u003e\n\u003cp\u003eGitHub link: \u003ca href=\"https://github.com/NVIDIA-RTX/NRI\"\u003ehttps://github.com/NVIDIA-RTX/NRI\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eNRI\u003c/em\u003e is a modular, extensible, low-level abstract rendering interface that was designed to support all low-level features of D3D12 and Vulkan GAPIs. At the same time, it aims to simplify usage and reduce the amount of code needed (especially compared with VK).\u003c/p\u003e","title":"Considering Transfering to Nvidia Render Interface (NRI)"},{"content":"We may have heard of these keywords: Depth Pre-Pass and Early-Z. But what situations do we actually need them for?\nOverdraw When rendering a complex 3D scene, multiple fragments may map to the same pixel on the screen ‚Äî for example, when one object is in front of another. The GPU will still execute the fragment shader for each layer of geometry, even though only the nearest fragment is visible in the final image.\nThis redundant work is called overdraw.\nExcessive overdraw wastes both fill rate and shader computation resources, especially in scenes with heavy pixel shading (e.g., complex lighting or post-processing).\nMinimizing overdraw is one of the key goals of any rendering optimization strategy.\nThe Depth Buffer The depth buffer (Z-buffer) keeps track of the closest depth value written for each pixel so far.\nWhen a new fragment is processed, the GPU compares its depth with the stored value to decide whether it‚Äôs visible (passes the depth test) or hidden (fails the depth test).\nIf Depth Test Passes ‚Üí the fragment is drawn, and the depth buffer is updated. If Depth Test Fails ‚Üí the fragment is discarded before writing to the color buffer. However, the key question is when this depth comparison happens relative to fragment shading ‚Äî and this is where Early-Z and Depth Pre-Pass come into play.\nEarly-Z Modern GPUs implement Early-Z rejection, meaning the depth test can be performed before the fragment shader runs.\nIf a fragment fails the test (i.e., it‚Äôs behind something already drawn), the GPU can skip executing the pixel shader entirely.\nThis saves a huge amount of computation, especially with expensive fragment programs.\nBut Early-Z has some caveats:\nIt only works if the fragment shader doesn‚Äôt modify the depth value or use discard/alpha-test operations that could change visibility. Certain rendering states (e.g., blending, alpha testing) may force the GPU to disable Early-Z to maintain correct visual output. In short: Early-Z works automatically when your shaders are ‚Äúsimple‚Äù ‚Äî i.e., they don‚Äôt interfere with depth writes or discards.\nTo enable Early-Z explicitly in Vulkan, just add one line to your fragment shader:\n1 layout(early_fragment_tests) in; Depth Pre-Pass The Depth Pre-Pass (also known as Z-Pre-Pass) is an explicit two-pass rendering strategy:\nFirst pass: Render all opaque geometries from front to back writing only to the depth buffer (no color writes, minimal shader). Second pass: Render the same geometries in the same order again, this time using full fragment shading but with depth testing enabled and depth writes disabled. Since the depth buffer now contains the nearest surfaces, most fragments that would be hidden are immediately rejected in the second pass.\nThis ensures that the heavy fragment shaders run only on visible pixels.\nDepending on which render path you are using, the second pass could be a G-buffer pass, a V-Buffer pass, or a lighting pass.\nNOTE Why render in front-to-back order?\nBecause we only care about the nearest visible surfaces.\nBy drawing the objects closer to the camera first, fragments from objects behind them will often fail the depth test and get skipped early, which significantly improves rendering performance.\nAdvantages Greatly reduces shading cost in high overdraw scenes. Consistent performance regardless of scene complexity. Works even when Early-Z is disabled due to complex shaders. Disadvantages Doubles the geometry workload (you render everything twice). May not be worth it for scenes that are vertex-heavy or have low overdraw. Requires good batching to avoid CPU bottlenecks. When to Use Which Scenario Early-Z Depth Pre-Pass Simple opaque materials ‚úÖ Enabled automatically üö´ Not needed Heavy fragment shaders with high overdraw ‚ö†Ô∏è May be disabled ‚úÖ Beneficial Alpha-tested materials (e.g., foliage) üö´ Often disabled ‚ö†Ô∏è Sometimes helpful Deferred rendering path ‚öôÔ∏è Partially effective ‚úÖ Commonly used In modern engines, many rendering pipelines dynamically decide whether to use a Depth Pre-Pass depending on the scene‚Äôs overdraw ratio and shader cost. For example, Unity and Unreal Engine enable it automatically for certain passes like deferred G-buffer generation or shadow casters.\nSummary Early-Z is a hardware feature that automatically skips hidden fragments when possible. Depth Pre-Pass is a manual rendering technique to guarantee that only visible fragments run expensive shaders. Both aim to reduce overdraw, improving frame rate and GPU efficiency. Understanding how and when to leverage these can make a big difference in the performance of your renderer ‚Äî especially in scenes with dense geometry or complex shading pipelines.\nHow did libvultra integrate them Sort all opaque geometries from front to back Depth Pre-Pass: Draw all sorted opaque geometries, only write depth values. G-Buffer Pass: Draw all sorted opaque geometries with Early-Z enabled, depth test only, no depth write. Draw other geometries with Early-Z disabled, depth test + depth write. https://github.com/zzxzzk115/libvultra/commit/2582ba27e27fbd0cc165ba9423b41f972e5affe6\nUseful Links https://wikis.khronos.org/opengl/Early_Fragment_Test ","permalink":"https://zzxzzk115.github.io/new-blog/posts/depth-pre-pass-and-early-z/","summary":"\u003cp\u003eWe may have heard of these keywords: \u003cstrong\u003eDepth Pre-Pass\u003c/strong\u003e and \u003cstrong\u003eEarly-Z\u003c/strong\u003e. But what situations do we actually need them for?\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"overdraw\"\u003eOverdraw\u003c/h2\u003e\n\u003cp\u003eWhen rendering a complex 3D scene, multiple fragments may map to the same pixel on the screen ‚Äî for example, when one object is in front of another. The GPU will still execute the fragment shader for each layer of geometry, even though only the nearest fragment is visible in the final image.\u003cbr\u003e\nThis redundant work is called \u003cstrong\u003eoverdraw\u003c/strong\u003e.\u003c/p\u003e","title":"Depth Pre-Pass and Early-Z"},{"content":"Problem Statement We need to check whether Godot pauses at breakpoints. However, Godot does not provide a direct API for this.\nThe Tricky Way If the program pauses at a breakpoint, the engine\u0026rsquo;s timer also pauses and we can check the delta time inside a _process function.\nIf now_tick - last_tick \u0026gt; PAUSE_THRESHOLD, this may be because the program has paused at breakpoints.\nThe DebugHelper class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # DebugHelper.gd extends Node var last_pause_duration: float = 0.0 var _last_ticks_time: float = 0.0 const PAUSE_THRESHOLD := 1.0 func _ready() -\u0026gt; void: process_mode = Node.PROCESS_MODE_ALWAYS _last_ticks_time = Time.get_ticks_msec() / 1000.0 func _process(_delta: float) -\u0026gt; void: var tick_now := Time.get_ticks_msec() / 1000.0 var tick_diff := tick_now - _last_ticks_time # Possible if tick_diff \u0026gt; PAUSE_THRESHOLD: last_pause_duration = tick_diff print(\u0026#34;[DebugHelper] Detected possible debug pause:\u0026#34;, last_pause_duration, \u0026#34;seconds\u0026#34;) # Emit events if you need _last_ticks_time = tick_now It could be an AutoLoad script. Alternatively, you can use signals or your custom event system to notify other systems when it detects potential debug pauses.\n","permalink":"https://zzxzzk115.github.io/new-blog/posts/how-to-check-if-godot-is-paused-at-breakpoints/","summary":"How to check if Godot is paused at breakpoints in a tricky way?","title":"How to Check if Godot Is Paused at Breakpoints"},{"content":"I‚Äôve tried both Hexo and VuePress, and they are both good static site generators. However, they both rely on Node.js, which is annoying. I have to worry about dependencies.\nUsing Hugo is much simpler. Just install it and everything works well with no dependencies. Also, you don\u0026rsquo;t need admin permission to install it.\nAbove all, I don‚Äôt need powerful or beautiful features for my blog. All I want is a simple design.\n","permalink":"https://zzxzzk115.github.io/new-blog/posts/why-hugo/","summary":"Why Hugo? Why not VuePress / Hexo?","title":"Why Hugo"},{"content":"MathJax Step 1 Create layouts/partials/extend_head.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 {{ if or .Params.math .Site.Params.math }} \u0026lt;script\u0026gt; MathJax = { tex: { inlineMath: [[\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;], [\u0026#39;$\u0026#39;, \u0026#39;$\u0026#39;]], displayMath: [[\u0026#39;$$\u0026#39;, \u0026#39;$$\u0026#39;], [\u0026#39;\\\\[\u0026#39;, \u0026#39;\\\\]\u0026#39;]], processEscapes: true, processEnvironments: true }, options: { skipHtmlTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;] } }; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://polyfill.io/v3/polyfill.min.js?features=es6\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} Step 2 Create layouts/_default/baseof.html:\n1 {{ partial \u0026#34;extend-head.html\u0026#34; . }} Step 3 Edit hugo.yaml, add markup-\u0026gt;goldmark section and enable math:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 markup: goldmark: renderer: unsafe: true extensions: passthrough: delimiters: block: - - \\[ - \\] - - $$ - $$ inline: - - \\( - \\) - - $ - $ enable: true params: math: true Favicon https://favicon.io/emoji-favicons/\nPut images into static/images/favicon/\nEdit hugo.yaml:\n1 2 3 4 5 6 7 params: assets: favicon: \u0026#34;images/favicon/favicon.ico\u0026#34; favicon16x16: \u0026#34;images/favicon/favicon-16x16.png\u0026#34; favicon32x32: \u0026#34;images/favicon/favicon-32x32.png\u0026#34; apple_touch_icon: \u0026#34;images/favicon/apple-touch-icon.png\u0026#34; # safari_pinned_tab: \u0026#34;images/favicon/safari-pinned-tab.svg\u0026#34; ","permalink":"https://zzxzzk115.github.io/new-blog/posts/hugo_confiig/","summary":"How to customize Hugo with theme PaperMod? Here are the instructions.","title":"Hugo PaperMod Customization"},{"content":"Mathjax Test Inline Equations This is an inline \\(a^*=x-b^*\\) equation.\nBlock Equations These are block equations:\n\\[a^*=x-b^*\\]\\[ a^*=x-b^* \\]\\[ a^*=x-b^* \\]These are also block equations:\n$$a^*=x-b^*$$$$ a^*=x-b^* $$$$ a^*=x-b^* $$Example The Rendering Equation:\n\\[ L_o(\\mathbf{x}, \\omega_o) = L_e(\\mathbf{x}, \\omega_o) + \\int_{\\Omega} f_r(\\mathbf{x}, \\omega_i, \\omega_o) \\, L_i(\\mathbf{x}, \\omega_i) \\, (\\omega_i \\cdot \\mathbf{n}) \\, d\\omega_i \\]Code Test 1#include \u0026lt;bits/stdc++.h\u0026gt; 2 3using namespace std; 4 5enum class Color { Red, Green, Blue }; 6 7struct Vec3 { 8 float x{}, y{}, z{}; 9 Vec3 operator+(const Vec3\u0026amp; o) const { return {x + o.x, y + o.y, z + o.z}; } 10}; 11 12int main() { 13 try { 14 vector\u0026lt;Vec3\u0026gt; points{{1,2,3}, {4,5,6}}; 15 auto add = [](Vec3 a, Vec3 b){ return a + b; }; 16 Vec3 sum = add(points[0], points[1]); 17 cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2); 18 cout \u0026lt;\u0026lt; \u0026#34;Sum: (\u0026#34; \u0026lt;\u0026lt; sum.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; sum.y \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; sum.z \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; 19 20 Color c = Color::Green; 21 if (c == Color::Green) 22 cout \u0026lt;\u0026lt; \u0026#34;It\u0026#39;s green!\\n\u0026#34;; 23 } catch (const exception\u0026amp; e) { 24 cerr \u0026lt;\u0026lt; \u0026#34;Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; 25 } 26} Image Test This is an image from /static/images/\nThis is a test image This is an image in the same directory as this markdown source file.\nThis is a test image \u0026lt;iframe\u0026gt;Test Alert CAUTION Content\nIMPORTANT Content\nNOTE Content\nTIP Content\nWARNING Content\n","permalink":"https://zzxzzk115.github.io/new-blog/posts/essential_test/","summary":"Essential test for blog post writting.","title":"Essential Test"}]